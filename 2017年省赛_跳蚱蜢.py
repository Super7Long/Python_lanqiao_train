# 如下图所示： 有 9 只盘子，排成 1 个圆圈。 其中 8 只盘子内装着 8 只蚱蜢，有一个是空盘。 我们把这些蚱蜢顺时针编号为 1 ~ 8。
#       4 5             5  4
#     3     6         6      3
#     2     7   --》  7      2
#      1 0 8           8 0 1
# 每只蚱蜢都可以跳到相邻的空盘中， 也可以再用点力，越过一个相邻的蚱蜢跳到空盘中。
# 请你计算一下，如果要使得蚱蜢们的队形改为按照逆时针排列， 并且保持空盘的位置不变（也就是1-8换位，2-7换位,...），至少要经过多少次跳跃？


# 广度优先遍历树找到满足的结点，结点深度即步数


from collections import deque
# 这里导入队列模块，因为python遍历列表太慢了

start = '012345678'     # 开始状态
end = '087654321'       # 结束状态
now = ('012345678', 0)  # 赋初态
s = [-2, -1, 1, 2]      # 可以移动的四个位置（0的左一、二、右一、二）
num = -1                # 树的层数
mydeque = deque()       # 创建队列
mydeque.append(now)     # 初态入队
ald = dict()    # 定义一个字典，存放已经出现过的状态，并将值赋为1
ald[start] = 1
fl, f2 = 0, 1   # 方便打印层数，两个层数不相同时输出
while mydeque:
    now = mydeque.popleft()  # 队首结点出队('012345678', 0)
    # print(now)
    f1 = now[1]
    if f1 != f2:
        print("第",now[1],"层")

    if now[0] == end:   # 如果当前结点，满足要求，结束
        print('结果', now[0],"要用",now[1],"步")
        break
    ald[now[0]] = 1   # 将当前结点存入字典以便排除重复结点
    for i in s:  # 访问四种情况
        n = list(now[0])
        p0 = n.index("0")
        n[p0], n[(p0+i+9)%9] = n[(p0+i+9)%9], n[p0]  # 交换0和另一个数的位置
        n = ''.join(n)
        if not ald.get(n, 0):    # 判断该情况是否已经存在
            mydeque.append((n, now[1] + 1))     # 结点入队
    f2 = now[1]
